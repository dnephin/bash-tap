#!/bin/bash
#
# While not directly TAP-specific, being able to mock stuff
# in tests is pretty useful.
#
# If you're using bash-tap-bootstrap, then just source this
# file in your tests from the bash-tap directory found by
# the bootstrap by including this line after you've sourced
# bash-tap-bootstrap:
#
#   . "$BASH_TAP_ROOT/bash-tap-mock"
#
# If you're not using bash-tap-bootstrap then copy this file
# to your test directory and source it with:
#
#   . $(dirname $0)/bash-tap-mock
#

if [ "${BASH_SOURCE[0]}" = "$0" ]; then
    # Being run directly, probably by test harness running entire dir.
    echo "1..0 # SKIP bash-tap-mock isn't a test file"
    exit 0
fi

function mock_function() {
    local original_name="$1"
    local mock_name="$2"
    local save_original_as="_btm_mocked_${original_name}"

    #echo "Original in place as:"
    #declare -f "$original_name"

    declare -F "$save_original_as" >/dev/null
    if [ $? != 0 ]; then
        #echo "Original '$original_name' not saved yet, saving as '$save_original_as'."
        _btm_copy_function "$original_name" "$save_original_as"
    fi
    _btm_copy_function "$mock_name" "$original_name"
    #echo "Mock in place as:"
    #declare -f "$original_name"
}

function restore_mocked_function() {
    local original_name="$1"
    local save_original_as="_btm_mocked_${original_name}"

    #echo "restore_mocked_function '$original_name'."
    declare -F "$save_original_as" >/dev/null
    if [ $? == 0 ]; then
        #echo "Original '$original_name' was saved, restoring from '$save_original_as'."
        _btm_copy_function "$save_original_as" "$original_name"
    else
        _btm_caller_error "Can't find saved original function '$original_name' to restore"
    fi
}

# Copied from http://stackoverflow.com/a/1203628/870000
function _btm_copy_function() {
    declare -F $1 >/dev/null || _btm_caller_error "Can't find function '$1' to copy"
    #echo "Copying '$1' to '$2'."
    eval "$(echo "${2}()"; declare -f ${1} | tail -n +2)"
}

#  Report an error from the POV of the first calling point outside this file
function _btm_caller_error() {
    local message="$*"

    local thisfile="${BASH_SOURCE[0]}"
    local file="$thisfile"
    local frame_num=2
    until [ "$file" != "$thisfile" ]; do
        frame=$(caller "$frame_num")
        IFS=' ' read line func file <<<"$frame"
    done

    echo "Error: $message, on line $line of $file" >&2
    exit 255
}
